% -*- Mode: BibTeX -*-
% gc.bib
% Garbage collection, with an emphasis on distributed GC.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% On-the-fly garbage collection (concurrent with mutator)
%%%


@Article{DijkstraLMSS78,
  author = 	"Edsger W. Dijkstra and Leslie Lamport and A. J. Martin and
		 C. S. Scholten and E. F. M. Steffens",
  title = 	"On-the-Fly Garbage Collection:  An Exercise in Cooperation",
  journal = 	CACM,
  year = 	1978,
  volume = 	21,
  number = 	11,
  pages = 	"966--975",
  month = 	Nov
}


@TechReport{Detlefs90a,
  author = 	"Detlefs, David L.",
  title = 	"Concurrent garbage collection for C++",
  institution = 	"Carnegie-Mellon Univ. Computer Science Dept.",
  year = 	"1990",
  number = 	"CMU-CS-90-119",
  address = 	"Pittsburgh, Pennsylvania",
  month = 	may
}



@TechReport{Detlefs90b,
  author = 	"Detlefs, David L.",
  title = 	"Concurrent, atomic garbage collection",
  institution = 	"Carnegie-Mellon Univ. Computer Science Dept.",
  year = 	"1990",
  number = 	"CMU-CS-90-177",
  address = 	"Pittsburgh, Pennsylvania",
  month = 	Oct,
  note = 	"PhD thesis"
}


@TechReport{Kolodner87,
  author = 	"Kolodner, Elliot K.",
  title = 	"Recovery using virtual memory",
  institution = 	"MIT Lab. for Computer Science",
  year = 	"1987",
  number = 	"MIT-LCS-TR-404",
  month = 	jul,
  note = 	"S.M. thesis"
}


@InProceedings{Boehm93,
  author = 	 "Hans-Juergen Boehm",
  title = 	 "Space efficient conservative garbage collection",
  crossref =     "PLDI93",
  pages =	 "197--206",
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Reference counting
%%%








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Distributed garbage collection
%%%


@InProceedings{TelTL86,
  author = 	"Gerard Tel and Richard B. Tan and Jan van Leeuwen",
  title = 	"The derivation of on-the-fly garbage collection algorithms
		 from distributed termination detection protocols",
  booktitle = 	"STACS '87:  4th Annual Symposium on Theoretical Aspects of
		 Computer Science",
  year = 	"1987",
  editor = 	"Brandenburg",
  pages = 	"445--455",
  publisher = 	"Springer-Verlag"
}


@InProceedings{Augusteijn,
  author = 	"Lex Augusteijn",
  title = 	"Garbage Collection in a Distributed Environment",
  booktitle	= "Proc PARLE Parallel Architectures and Languages
			   Europe (Springer-Verlag LNCS 259)",
  pages = 	"75--93",
  year		= 1987,
  month		= jun,
  address	= "Eindhoven, The Netherlands"
}




@InProceedings{KoikeT1989,
  author = 	"Hanpei Koike and Hidehiko Tanaka",
  title = 	"Generation scavenging {GC} on Distributed-Memory Parallel
		 Computers",
  booktitle = "ASTEM",
  NEEDpages = 	 "",
  year = 	 1989,
  NEEDaddress = 	 "",
  month = 	 nov,
}


@Article{Halstead85,
  author = 	"Halstead, Jr., Robert H.",
  title = 	"Multilisp:  A Language for Concurrent Symbolic Computation",
  journal = 	toplas,
  year = 	1985,
  volume = 	7,
  number = 	4,
  pages = 	"501--538",
  month = 	Oct
}


@techreport{AliH85,
	author		= "    Ali, Khayri M.
			   and Haridi, Seif",
	title		= "Global Garbage Collection for Distributed
			   Heap Storage Systems",
	institution	= "IBM Thomas J. Watson Research Center",
	address		= "PO Box 218, Yorktown Heights NY 10598",
	year		= 1985,
	month		= feb,
	number		= "RC 11082 (\#49769)"
}


@inproceedings{Rudalics86,
	author		= "Rudalics, Martin",
	title		= "Distributed Copying Garbage Collection",
	booktitle	= "Proc Lisp and Functional Programming Conf.",
	pages		= "364--372",
	year		= 1986,
	month		= aug
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fault-tolerant distributed garbage collection
%%%

@inproceedings{LiskovL86,
	author		= "    Liskov, Barbara
			   and Ladin, Rivka",
	title		= "Highly-Available Distributed Services and
			   Fault-Tolerant Distributed Garbage Collection",
	booktitle	= "Proc 5th Annual ACM Symp on Principles of
			   Distributed Computing",
	pages		= "29--39",
	year		= 1986,
	month		= aug,
	address		= "Calgary, Alberta, Canada"
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Shared-memory garbage collection
%%%



@InProceedings{SharmaS91,
  author = 	 "Ravi Sharma and Mary Lou Soffa",
  title = 	 "Parallel generational garbage collection",
  booktitle =	 "Object-Oriented Programming Systems, Languages, and
		  Applications '91",
  pages =	 "16--32",
  organization = "ACM",
  address =	 "Phoenix, Arizona",
  year =         1991,
  month =	 oct # "~6--11,"
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Finalization
%%%

@InProceedings{Boehm2003,
  author = 	 "Hans-J. Boehm",
  title = 	 "Destructors, Finalizers, and Synchronization",
  crossref =     "POPL2003",
  pages =	 "262--272",
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Other bibliographies
%%%

@techreport{NS94102,
  author = "Nandakumar Sankaran",
  title = "A Bibliography on Garbage Collection",
  institution = "Clemson University",
  address = "$4^{th}$ Floor, R. C. Edwards Hall, Computer Science
             Department, Clemson, SC 29631",
  month = feb,
  year = 1994,
  type = "Technical Report",
  number = "94-102",
  note = "This paper references literature related to garbage
		  collection in uniprocessor, parallel, distributed,
		  real-time, object-oriented, functional and logic
		  programming systems.",
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Local talent
%%%






@Unpublished{Vandevoorde88,
  author = 	 "Mark T. Vandevoorde",
  title = 	 "An Evaluation of Garbage Collection Algorithms for
		  Multiprocessors",
  note = 	 "Area Exam Paper",
  year =	 1988,
  month =	 Dec # "~7,"
}

@InProceedings{VG94,
  author =       "Mark T. Vandevoorde and John V. Guttag",
  title =        "Using specialized procedures and specification-based analysis
                  to reduce the runtime costs of modularity",
  crossref =     "FSE94",
  pages =        "121--127",
}

@Unpublished{Hsieh91,
  author = 	 "Wilson C. Hsieh",
  title = 	 "Garbage Collection for Parallel and Distributed Systems",
  note = 	 "Area Examination Paper",
  year =	 1991,
  month =	 Dec # "~5,"
}


@Unpublished{Keen92,
  author = 	 "John S. Keen",
  title = 	 "A Critical Survey of Some Concurrent Garbage Collection
		  Algorithms",
  note = 	 "Area examination report",
  year =	 1992,
  month =	 Jun # "~3,"
}












%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Grouping information to improve locality
%%%








@InProceedings{WLM91,
  author = 	 "Paul R. Wilson and Michael S. Lam and Thomas G. Moher",
  title = 	 "Effective ``Static-graph'' Reorganization to Improve
		  Locality in Garbage-Collected Systems",
  crossref =  "PLDI91",
  pages = 	 "177--191"
}

@INPROCEEDINGS{WM89,
  crossref =	"OOPSLA89",
	AUTHOR = "Paul R. Wilson and Thomas G. Moher",
	TITLE = "Design of the {Opportunistic Garbage Collector}",
	PAGES = "23--35"
}

@TechReport{Shaw87,
  author = 	 "Robert A. Shaw",
  title = 	 "Improving Garbage Collector Performance in Virtual Memory",
  institution =  "Stanford University",
  year = 	 1987,
  number = 	 "CSL-TR-87-323",
  month = 	 mar
}

@PHDTHESIS{Shaw88,
	AUTHOR = "Robert A. Shaw",
	TITLE = "Empirical Analysis of a {LISP} System",
	SCHOOL = "Stanford University",
	MONTH = feb,
	YEAR = 1988,
	NOTE = "Available as Technical Report CSL-TR-88-351"
}

@InProceedings{Ungar84,
  author = 	 "David Ungar",
  title = 	 "Generation Scavenging:  A Non-disruptive High Performance
		  Storage Reclamation Algorithm",
  BookTitle={SIGSOFT/SIGPLAN Notices Practical Programming Environments Conference},
  Organization={ACM},
  pages =	 "157--167",
  year =	 1984,
  month =	 Apr
}


@INPROCEEDINGS{UngarJ88,
  crossref =	"OOPSLA88",
	AUTHOR = "David Ungar and Frank Jackson",
	TITLE = "Tenuring Policies for Generation-Based Storage Reclamation",
	PAGES = "1--17"
}

@Book{Ungar87,
  author = 	"David Michael Ungar",
  title = 	"The Design and Evaluation of a High Performance Smalltalk
  		System",
  publisher = 	"MIT Press",
  year = 	1987,
  series = 	"ACM Distinguished Dissertations",
  address = 	"Cambridge, Massachusetts",
  note = 	"Ph.D. Dissertation, University of California at Berkeley,
  February 1986"
}


@InProceedings{Moon84,
  author = 	 "David A. Moon",
  title = 	 "Garbage collection in a large lisp system",
  booktitle =	 "Proceedings of the 1984 ACM Symposium on Lisp and
		  Functional Programming",
  pages =	 "235--246",
  year =	 1984,
  month =	 Aug
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% I have it, but haven't read it.
%%%






@inproceedings{HudakK82,
	author		= "    Hudak, Paul
			   and Keller, Robert M.",
	title		= "Garbage Collection and Task Deletion in
			   Distributed Applicative Processing Systems",
	booktitle	= "Proc ACM Symp on Lisp and Functional Programming",
	pages		= "168--178",
	year		= 1982,
	month		= aug,
	address		= "{Pittsburgh, Pennsylvania}"
}

@inproceedings{Halstead84,
	author		= "Halstead, Jr., Robert H.",
	title		= "Implementation of Multilisp:  Lisp on a
			   Multiprocessor",
	booktitle	= "Proc ACM Symp on Lisp and Functional Programming",
	pages		= "9--17",
	year		= 1984,
	month		= Aug,
	address		= "{Austin, Texas}"
}

@inproceedings{MillerE89,
	author		= "    Miller, James S.
			   and Epstein, Barbara S.",
	title		= "Garbage Collection in MultiScheme (Preliminary Version)",
	booktitle	= "Proc Parallel Lisp:  Languages and Systems
			   (Springer-Verlag LNCS 441)",
	pages		= "138--160",
	year		= 1989,
	month		= Jun # "5--8,",
	address		= "{Sendai, Japan}"
}

@inproceedings{Hughes85,
	author		= "Hughes, John",
	title		= "A Distributed Garbage Collection Algorithm",
	booktitle	= "Proc Functional Programming Languages and
			   Computer Architecture (Springer-Verlag LNCS 201)",
	editor		= "J. P. Jouannaud",
	pages		= "256--272",
	year		= 1985,
	month		= sep,
	address		= "{Nancy, France}"
}


@techreport{ManciniS88,
	author		= "    Mancini, L. V.
			   and Shrivastava, S. K.",
	title		= "Fault-tolerant reference counting for garbage
			   collection in distributed systems",
	institution	= "{University of Newcastle upon Tyne}",
	address		= "{Computing Laboratory,
			   University of Newcastle upon Tyne, England}",
	year		= 1988,
	month		= jun,
	number		= "260"
}

@techreport{EllisLA88,
	author		= "    Ellis, John R.
			   and Li, Kai
			   and Appel, Andrew W.",
	title		= "Real-time Concurrent Collection
			   on Stock Multiprocessors",
	institution	= "{DEC Systems Research Center}",
	address		= "{130 Lytton Ave., Palo Alto, California}",
	year		= 1988,
	month		= feb,
	number		= 25
}

@mastersthesis{Venkatasubramanian92,
	author		= "Venkatasubramanian, Nalini",
	title		= "Hierarchical Garbage Collection in Scalable
			   Distributed Systems",
	school		= "University of Illinois at Urbana-Champaign",
	year		= 1992
}

@TechReport{Vestal87,
  author = 	 "Stephen C. Vestal",
  title = 	 "Garbage collection: an exercise in
                  distributed, fault-tolerant programming",
  institution =  "University of Washington Department of Computer Science",
  year = 	 1987,
  number =	 "87-01-03",
  month =	 Jan
}



@InProceedings{DiwanMH92,
  author = 	 "Amer Diwan and Eliot Moss and Richard Hudson",
  title = 	 "Compiler support for garbage collection in a statically
		  typed language",
  crossref =     "PLDI92",
  pages =	 "273--282",
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% From John Keen
%%%

% Some of these may be duplicates of stuff that's above.
% And beware the odd or misleading use of some fields, especially institution.

@article{Baker78,
	author		= "Baker, Jr., Henry G.",
	title		= "List Processing in Real Time on a Serial Computer",
	journal		= CACM,
	volume		= 21,
	number		= 4,
	month		= Apr,
	year		= 1978,
	pages		= "280--294"
}

@inproceedings{NorthR87,
	author		= "    North, S. C.
			   and Reppy, J. H.",
	title		= "Concurrent Garbage Collection on Stock Hardware",
	booktitle	= "Proc Functional Programming Languages and
			   Computer Architecture (Springer-Verlag LNCS 274)",
	pages		= "113--133",
	year		= 1987,
	month		= sep,
	address		= "{Portland, Oregon}"
}

@inproceedings{Brooks84,
	author		= "Brooks, Rodney A.",
	title		= "Trading Data Space for Reduced Time and Code
			   Space in Real-Time Garbage Collection on
			   Stock Hardware",
	booktitle	= "Proc ACM Symp on Lisp and Functional Programming",
	pages		= "256--262",
	year		= 1984,
	month		= aug,
	address		= "{Austin, Texas}"
}




@inproceedings{Ali85b,
	author		= "Ali, Khayri A. M.",
	title		= "Garbage Collection Schemes for Distributed
			   Storage Systems",
	booktitle	= "Proc Workshop on Implementation of
			   Functional Languages",
	pages		= "422--428",
	year		= 1985,
	month		= feb
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@article{Fenichel69,
	author		= "    Fenichel, Robert R.
			   and Yochelson, Jerome C.",
	title		= "A LISP Garbage-Collector for Virtual-Memory
			   Computer Systems",
	journal		= CACM,
	volume		= 12,
	number		= 11,
	month		= nov,
	year		= 1969,
	pages		= "611--612"
}

@article{Steele75,
	author		= "{Steele Jr.}, Guy L.",
	title		= "Multiprocessing Compactifying Garbage Collection",
	journal		= CACM,
	volume		= 18,
	number		= 9,
	month		= sep,
	year		= 1975,
	pages		= "495--508"
}

@article{Schorr67,
	author		= "    Schorr, H.
			   and Waite, W.M.",
	title		= "An Efficient Machine-Independent Procedure for
			   Garbage Collection in Various List Structures",
	journal		= CACM,
	volume		= 10,
	number		= 8,
	month		= aug,
	year		= 1967,
	pages		= "501--506"
}


@article{Lieberman83,
	author		= "    Lieberman, Henry
			   and Hewitt, Carl",
	title		= "A Real-Time Garbage Collector Based on the
			   Lifetimes of Objects",
	journal		= CACM,
	volume		= 26,
	number		= 6,
	month		= jun,
	year		= 1983,
	pages		= "419--429"
}

@inproceedings{Wise85,
	author		= "Wise, David S.",
	title		= "Design for a Multiprocessing Heap with On-board
			   Reference Counting",
	booktitle	= "Proc.\ Functional Programming Languages and
			   Computer Architecture (Springer-Verlag LNCS 201)",
	pages		= "289--303",
	year		= 1985,
	month		= sep,
	address		= "{Nancy, France}"
}

@inproceedings{Brownbridge85,
	author		= "Brownbridge, D.R.",
	title		= "Cyclic Reference Counting for Combinator Machines",
	booktitle	= "Proc Functional Programming Languages and
			   Computer Architecture (Springer-Verlag LNCS 201)",
	pages		= "273--288",
	year		= 1985,
	month		= sep,
	address		= "{Nancy, France}"
}

@inproceedings{Chiueh91,
	author		= "Chiueh, Tzi-cker",
	title		= "An Architectural Technique for Cache-level Garbage
			   Collection",
	booktitle	= "Proc Functional Programming Languages and
			   Computer Architecture",
	pages		= "520--537",
	year		= 1991,
	month		= aug,
	address		= "{Cambridge, Massachusetts}"
}


@inproceedings{Zorn90,
	author		= "Zorn, Benjamin",
	title		= "Comparing Mark-and-sweep and Stop-and-copy
			   Garbage Collection",
	booktitle	= "Proc ACM Symp on Lisp and Functional Programming",
	pages		= "87--98",
	year		= 1990,
	month		= jun,
	address		= "{Nice, France}"
}

@inproceedings{Thacker87,
	author		= "    Thacker, Charles P.
			   and Stewart, Lawrence C.",
	title		= "Firefly:  A Multiprocessor Workstation",
	booktitle	= "Proc 2nd Int'l Conf on Architectural Support for
			   Programming Langs and Operating Systems (ASPLOS II)",
	pages		= "164--172",
	year		= 1987,
	month		= oct,
	address		= "{Palo Alto, California}"
}

@inproceedings{Tel87,
	author		= "    Tel, Gerard
			   and Tan, Richard B.
			   and {van Leeuwen}, Jan",
	title		= "The Derivation of On-the-fly Garbage Collection
			   Algorithms from Distributed Termination Detection
			   Protocols",
	booktitle	= "Proc 4th Annual Symp on Theoretical Aspects of
			   Computer Science (Springer-Verlag LNCS 247)",
	pages		= "445--455",
	year		= 1987,
	month		= feb,
	address		= "{Passau, Federal Republic of Germany}"
}

@inproceedings{Tel91,
	author		= "    Tel, Gerard
			   and Mattern, Friedemann",
	title		= "The Derivation of Distributed Termination Detection
			   Algorithms from Garbage Collection Schemes",
	booktitle	= "Proc PARLE '91 Parallel Architectures and Languages
			   Europe",
	pages		= "137--149",
	year		= 1991,
	month		= jun,
	address		= "{Eindhoven, The Netherlands}"
}

@inproceedings{Piquer91,
	author		= "Piquer, Jos\'{e} M.",
	title		= "Indirect Reference Counting:  A Distributed Garbage
			   Collection Algorithm",
	booktitle	= "Proc PARLE '91 Parallel Architectures and Languages
			   Europe",
	pages		= "150--165",
	year		= 1991,
	month		= jun,
	address		= "{Eindhoven, The Netherlands}"
}

@inproceedings{Queinnec89,
	author		= "    Queinnec, Christian
			   and Beaudoing, Barbara
			   and Queille, Jean-Pierre",
	title		= "Mark DURING Sweep rather than Mark THEN Sweep",
	booktitle	= "Proc PARLE '89 Parallel Architectures and Languages
			   Europe (Springer-Verlag LNCS 365)",
	pages		= "224--237",
	year		= 1989,
	month		= jun,
	address		= "{Eindhoven, The Netherlands}"
}

@inproceedings{Lester89,
	author		= "Lester, David R.",
	title		= "An Efficient Distributed Garbage Collection
			   Algorithm",
	booktitle	= "Proc PARLE '89 Parallel Architectures and Languages
			   Europe (Springer-Verlag LNCS 365)",
	pages		= "207--223",
	year		= 1989,
	month		= jun,
	address		= "{Eindhoven, The Netherlands}"
}

@inproceedings{Bevan87,
	author		= "Bevan, D.I.",
	title		= "Distributed Garbage Collection Using Reference Counting",
	booktitle	= "Proc PARLE Parallel Architectures and Languages
			   Europe (Springer-Verlag LNCS 259)",
	pages		= "176--187",
	year		= 1987,
	month		= jun,
	address		= "{Eindhoven, The Netherlands}"
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Database searches and other possibilities
%%%






@PhdThesis{Ali84,
  author = 	 "Ali, K. A. M.",
  title = 	 "Object Oriented Storage Management and Garbage Collection
		  in Distributed Systems",
  school = 	 "Royal Institute of Technology",
  year = 	 1984,
  address =	 "Stockholm",
  month =	 dec
}

@MastersThesis{Nori79,
  author = 	 "Nori, A. K.",
  title = 	 "A Storage Reclamation Scheme for Applicative
		  Multiprocessor Systems",
  school = 	 "University of Utah",
  year = 	 1979,
  month =	 dec
}































































%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% From Keene
%%%


@techreport{Zorn89,
	author		= "Zorn, Benjamin G.",
	title		= "Comparative Performance Evaluation of
			   Garbage Collection Algorithms",
	institution	= "{Univ of California, Berkeley}",
	year		= 1989,
	month		= dec,
	number		= "UCB/CSD 89/544"
}

@techreport{Ellis88,
	author		= "    Ellis, John R.
			   and Li, Kai
			   and Appel, Andrew W.",
	title		= "Real-time Concurrent Collection
			   on Stock Multiprocessors",
	institution	= "{DEC Systems Research Centre}",
	address		= "{130 Lytton Ave., Palo Alto, California}",
	year		= 1988,
 	month		= feb,
	number		= 25,
	note		= "The contents of this report also appear in
			   {\em Proc ACM Conf on Programming Language Design
			   and Implementation}, pages 11--20, Atlanta,
			   Georgia, June 1988."
}

@techreport{DeTreville90,
	author		= "DeTreville, John",
	title		= "Experience with Concurrent Garbage
			   Collectors for Modula-2+",
	institution	= "{DEC Systems Research Centre}",
	address		= "{130 Lytton Ave., Palo Alto, California}",
	year		= 1990,
 	month		= nov,
	number		= 64
}

@techreport{Ali85,
	author		= "    Ali, Khayri M.
			   and Haridi, Seif",
	title		= "Global Garbage Collection for Distributed
			   Heap Storage Systems",
	institution	= "{Royal Institute of Technology, Sweden,
			    and IBM Thomas Watson Research Center}",
	address		= "{PO Box 218, Yorktown Heights NY 10598}",
	year		= 1985,
	month		= feb,
	number		= "IBM RC 11082 (\#49769)"
}

@techreport{Herlihy90,
	author		= "    Herlihy, Maurice
			   and Moss, J. Eliot B.",
	title		= "Non-Blocking Garbage Collection for Multiprocessors",
	institution	= "{DEC Cambridge Research Lab}",
	address		= "{Cambridge, Massachusetts}",
	year		= 1990,
	month		= nov,
	number		= "CRL 90/9"
}

@mastersthesis{Totty88,
	author		= "Totty, Brian",
	title		= "An Operating Environment for the Jellybean Machine",
	school		= "Massachusetts Institute of Technology",
	year		= 1988
}

@article{Dijkstra78,
	author		= "    Dijkstra, Edsger W.
			   and Lamport, Leslie
			   and Martin, A.J.
			   and Scholten, C.S.
			   and Steffens, E.F.M.",
	title		= "On-the-Fly Garbage Collection:  An Exercise
			   in Cooperation",
	journal		= "Comm. of ACM",
	volume		= "21",
	number		= 11,
	month		= nov,
	year		= 1978,
	pages		= "966--975"
}


@article{Cohen81,
	author		= "Cohen, Jacques",
	institution	= "{Brandeis University}",
	title		= "Garbage Collection of Linked Data Structures",
	journal		= "ACM Computing Surveys",
	volume		= 13,
	number		= 3,
	month		= sep,
	year		= 1981,
	pages		= "341--367"
}

@inproceedings{North87,
	author		= "    North, S.C.
			   and Reppy, J.H.",
	title		= "Concurrent Garbage Collection on Stock Hardware",
	booktitle	= "Proc Functional Programming Languages and
			   Computer Architecture (Springer-Verlag LNCS 274)",
	pages		= "113--133",
	year		= 1987,
	month		= sep,
	address		= "{Portland, Oregon}"
}

@inproceedings{Miller89,
	author		= "    Miller, James S.
			   and Epstein, Barbara S.",
	title		= "Garbage Collection in MultiScheme (Preliminary Version)",
	booktitle	= "Proc Parallel Lisp:  Languages and Systems
			   (Springer-Verlag LNCS 441)",
	pages		= "138--160",
	year		= 1989,
	month		= jun,
	address		= "{Sendai, Japan}"
}

@inproceedings{Hudak82,
	author		= "    Hudak, Paul
			   and Keller, Robert M.",
	title		= "Garbage Collection and Task Deletion in
			   Distributed Applicative Processing Systems",
	booktitle	= "Proc ACM Symp on Lisp and Functional Programming",
	pages		= "168--178",
	year		= 1982,
	month		= aug,
	address		= "{Pittsburgh, Pennsylvania}"
}

@inproceedings{Liskov86,
	author		= "    Liskov, Barbara
			   and Ladin, Rivka",
	title		= "Highly-Available Distributed Services and
			   Fault-Tolerant Distributed Garbage Collection",
	booktitle	= "Proc 5th Annual ACM Symp on Principles of
			   Distributed Computing",
	pages		= "29--39",
	year		= 1986,
	month		= aug,
	address		= "{Calgary, Alberta, Canada}"
}

@inproceedings{Watson87,
	author		= "    Watson, Paul
			   and Watson, Ian",
	title		= "An Efficient Garbage Collection Scheme for Parallel
			   Computer Architectures",
	booktitle	= "Proc PARLE Parallel Architectures and Languages
			   Europe (Springer-Verlag LNCS 259)",
	pages		= "432--443",
	year		= 1987,
	month		= jun,
	address		= "{Eindhoven, The Netherlands}"
}

@inproceedings{Augusteijn87,
	author		= "Augusteijn, Lex",
	title		= "Garbage Collection in a Distributed Environment",
	booktitle	= "Proc PARLE Parallel Architectures and Languages
			   Europe (Springer-Verlag LNCS 259)",
	pages		= "75--93",
	year		= 1987,
	month		= jun,
	address		= "{Eindhoven, The Netherlands}"
}

@inproceedings{Goldberg89,
	author		= "Goldberg, Benjamin",
	title		= "Generational Reference Counting:
			   A Reduced-Communication Distributed
			   Storage Reclamation Scheme",
	booktitle	= "Proc ACM Conf on Programming Language Design
			   and Implementation",
	pages		= "313--321",
	year		= 1989,
	month		= jun,
	address		= "{Portland, Oregon}"
}

@inproceedings{Goldberg91,
	author		= "Goldberg, Benjamin",
	title		= "Tag-Free Garbage Collection for Strongly
			   Typed Programming Languages",
	booktitle	= "Proc ACM Conf on Programming Language Design
			   and Implementation",
	pages		= "165--176",
	year		= 1991,
	month		= jun,
	address		= "{Toronto, Canada}"
}

@inproceedings{Wilson91,
	author		= "    Wilson, Paul R.
			   and Lam, Michael S.
			   and Moher, Thomas G.",
	title		= "Effective ``Static-graph'' Reorganization
			   to Improve Locality in Garbage-Collected Systems",
	booktitle	= "Proc ACM Conf on Programming Language Design
			   and Implementation",
	pages		= "177--191",
	year		= 1991,
	month		= jun,
	address		= "{Toronto, Canada}"
}

@inproceedings{Boehm91,
	author		= "    Boehm, Hans-J.
			   and Demers, Alan J.
			   and Shenker, Scott",
	title		= "Mostly Parallel Garbage Collection",
	booktitle	= "Proc ACM Conf on Programming Language Design
			   and Implementation",
	pages		= "157--164",
	year		= 1991,
	month		= jun,
	address		= "{Toronto, Canada}"
}

@inproceedings{Appel88,
	author		= "    Appel, Andrew W.
			   and Ellis, John R.
			   and Li, Kai",
	title		= "Real-time Concurrent Collection on Stock
			   Multiprocessors",
	booktitle	= "Proc ACM Conf on Programming Language Design
			   and Implementation",
	pages		= "11--20",
	year		= 1988,
	month		= jun,
	address		= "{Atlanta, Georgia}"
}

@inproceedings{Sharma91,
	author		= "    Sharma, Ravi
			   and Soffa, Mary Lou",
	title		= "Parallel Generational Garbage Collection",
	booktitle	= "Proc Object-Oriented Programming Systems,
			   Languages, and Applications Conf",
	pages		= "16--32",
	year		= 1991,
	month		= oct,
	address		= "{Phoenix, Arizona}"
}

@inproceedings{Xu89,
	author		= "    Xu, Lu
			   and Koike, Hanpei
			   and Tanaka, Hidehiko",
	title		= "Distributed Garbage Collection for the
			   Parallel Inference Machine PIE64",
	booktitle	= "Proc IFIP 11th World Computer Congress",
	pages		= "1161--1166",
	year		= 1989,
	month		= aug,
	address		= "{San Francisco, California}"
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Miscellaneous
%%%




@InProceedings{JumpM2007,
  author = 	 "Maria Jump and Kathryn S. McKinley",
  title = 	 "Cork: Dynamic memory leak detection for garbage-collected languages",
  crossref =     "POPL2007",
  NEEDpages = 	 "*",
  abstract =
   "A \emph{memory leak} in a garbage-collected program occurs when the program
    inadvertently maintains references to objects that it no longer
    needs. Memory leaks cause systematic heap growth, degrading performance and
    resulting in program crashes after perhaps days or weeks of
    execution. Prior approaches for detecting memory leaks rely on heap
    differencing or detailed object statistics which store state proportional
    to the number of objects in the heap. These overheads preclude their use on
    the same processor for deployed long-running applications.
    \par
    This paper introduces a dynamic heap-summarization technique based on type
    that accurately identifies leaks, is space efficient (adding less than 1\%
    to the heap), and is time efficient (adding 2.3\% on average to total
    execution time). We implement this approach in \emph{Cork} which utilizes
    dynamic type information and garbage collection to summarize the live
    objects in a \emph{type points-from graph} (\emph{TPFG}) whose nodes
    (types) and edges (references between types) are annotated with
    volume. \emph{Cork} compares \emph{TPFG}s across multiple collections,
    identifies growing data structures, and computes a \emph{type slice} for
    the user. \emph{Cork} is accurate: it identifies systematic heap growth
    with no false positives in 4 of 15 benchmarks we tested. Cork's slice
    report enabled us (non-experts) to quickly eliminate growing data
    structures in SPECjbb2000 and Eclipse, something their developers had not
    previously done. Cork is accurate, scalable, and efficient enough to
    consider using online.",
}



@InProceedings{ReichenbackISAG2010,
  author = 	 "Christoph Reichenbach and Neil Immerman and Yannis Smaragdakis and Edward Aftandilian and Samuel Z. Guyer",
  title = 	 "What can the {GC} compute efficiently?  A language for heap assertions at {GC} time",
  crossref =     "OOPSLA2010",
  pages = 	 "256--269",
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Quantifying the cost of garbage collection
%%%


@InProceedings{HertzB2005,
  author = 	 "Hertz, Matthew and Berger, Emery D.",
  title = 	 "Quantifying the performance of garbage collection vs. explicit memory management",
  crossref =  "OOPSLA2005",
  pages = 	 "313–326",
  abstract =
   {Garbage collection yields numerous software engineering benefits, but its
    quantitative impact on performance remains elusive. One can compare the cost of
    conservative garbage collection to explicit memory management in C/C++ programs by
    linking in an appropriate collector. This kind of direct comparison is not possible
    for languages designed for garbage collection (e.g., Java), because programs in these
    languages naturally do not contain calls to free. Thus, the actual gap between the
    time and space performance of explicit memory management and precise, copying garbage
    collection remains unknown.We introduce a novel experimental methodology that lets us
    quantify the performance of precise garbage collection versus explicit memory
    management. Our system allows us to treat unaltered Java programs as if they used
    explicit memory management by relying on oracles to insert calls to free. These
    oracles are generated from profile information gathered in earlier application
    runs. By executing inside an architecturally-detailed simulator, this "oracular"
    memory manager eliminates the effects of consulting an oracle while measuring the
    costs of calling malloc and free. We evaluate two different oracles: a liveness-based
    oracle that aggressively frees objects immediately after their last use, and a
    reachability-based oracle that conservatively frees objects just after they are last
    reachable. These oracles span the range of possible placement of explicit
    deallocation calls.We compare explicit memory management to both copying and
    non-copying garbage collectors across a range of benchmarks using the oracular memory
    manager, and present real (non-simulated) runs that lend further validity to our
    results. These results quantify the time-space tradeoff of garbage collection: with
    five times as much memory, an Appel-style generational collector with a non-copying
    mature space matches the performance of reachability-based explicit memory
    management. With only three times as much memory, the collector runs on average 17\%
    slower than explicit memory management. However, with only twice as much memory,
    garbage collection degrades performance by nearly 70\%. When physical memory is
    scarce, paging causes garbage collection to run an order of magnitude slower than
    explicit memory management.},
}


@InProceedings{SareenB2022,
  author = 	 "Sareen, Kunal and Blackburn, Stephen Michael",
  title = 	 "Better understanding the costs and benefits of automatic memory management",
  crossref =  "MPLR2022",
  pages = 	 "29–44",
  abstract =
   {Automatic memory management relieves programmers of the burden of having to reason
    about object lifetimes in order to soundly reclaim allocated memory. However, this
    automation comes at a cost. The cost and benefits of garbage collection relative to
    manual memory management have been the subject of contention for a long time, and
    will likely remain so. However, until now, the question is surprisingly
    under-studied. We examine the costs and benefits of garbage collection through four
    studies, exploring: We conduct this study in a contemporary setting using recent CPU
    microarchitectures, and novel methodologies including a mark-sweep collector built
    upon off-the-shelf free-list allocators, allowing us to shed new light on garbage
    collection overheads in a modern context. We find that: The costs and benefits of
    garbage collection are likely to remain subject to contentious discussion. However,
    the methodologies and evaluations we present here provide a deeper understanding of
    the differences in costs between manual memory management and garbage collection.},
}


@Article{Zorn1993,
  author = 	 "Zorn, Benjamin",
  title = 	 "The measured cost of conservative garbage collection",
  journal = 	 SPE,
  year = 	 1993,
  volume = 	 23,
  number = 	 7,
  pages = 	 "733-756",
  abstract =
   {Because dynamic memory management is an important part of a large class of computer
    programs, high-performance algorithms for dynamic memory management have been, and
    will continue to be, of considerable interest. Experience indicates that for many
    programs, dynamic storage allocation is so important that programmers feel compelled
    to write and use their own domain-specific allocators to avoid the overhead of system
    libraries. As an alternative to explicit storage management techniques, conservative
    garbage collection has been suggested as an important algorithm for dynamic storage
    management in C programs. In this paper, I evaluate the costs of different dynamic
    storage management algorithms, including domain-specific allocators, widely-used
    general-purpose allocators, and a publicly available conservative garbage collection
    algorithm. Surprisingly, I find that programmer enhancements often have little effect
    on program performance. I also find that the true cost of conservative garbage
    collection is not the CPU overhead, but the memory system overhead of the
    algorithm. I conclude that conservative garbage collection is a promising alternative
    to explicit storage management and that the performance of conservative collection is
    likely to improve in the future. C programmers should now seriously consider using
    conservative garbage collection instead of explicitly calling free in programs they
    write.},
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Garbage collection coexisting with manual memory management (regions, free)
%%%


@InProceedings{RafkindWRF2009,
  author = 	 "Rafkind, Jon and Wick, Adam and Regehr, John and Flatt, Matthew",
  title = 	 "Precise garbage collection for {C}",
  crossref =  "ISMM2009",
  pages = 	 "39-48",
  abstract =
   {Magpie is a source-to-source transformation for C programs that enables precise
    garbage collection, where precise means that integers are not confused with pointers,
    and the liveness of a pointer is apparent at the source level. Precise GC is
    primarily useful for long-running programs and programs that interact with untrusted
    components. In particular, we have successfully deployed precise GC in the C
    implementation of a language run-time system that was originally designed to use
    conservative GC. We also report on our experience in transforming parts of the Linux
    kernel to use precise GC instead of manual memory management.},
}


@InProceedings{DegenbaevEHHLP2018,
  author = 	 "Degenbaev, Ulan and Eisinger, Jochen and Hara, Kentaro and Hlopko, Marcel and Lippautz, Michael and Payer, Hannes",
  title = 	 "Cross-component garbage collection",
  crossref =  "OOPSLA2018",
  abstract =
   {Embedding a modern language runtime as a component in a larger software system is
    popular these days. Communication between these systems often requires keeping
    references to each others' objects. In this paper we present and discuss the problem
    of cross-component memory management where reference cycles across component
    boundaries may lead to memory leaks and premature reclamation of objects may lead to
    dangling cross-component references. We provide a generic algorithm for effective,
    efficient, and safe garbage collection over component boundaries, which we call
    cross-component tracing. We designed and implemented cross-component tracing in the
    Chrome web browser where the JavaScript virtual machine V8 is embedded into the
    rendering engine Blink. Cross-component tracing from V8's JavaScript heap to Blink's
    C++ heap improves garbage collection latency and eliminates long-standing memory
    leaks for real websites in Chrome. We show how cross-component tracing can help web
    developers to reason about reachability and retainment of objects spanning both V8
    and Blink components based on Chrome's heap snapshot memory tool. Cross-component
    tracing was enabled by default for all websites in Chrome version 57 and is also
    deployed in other widely used software systems such as Opera, Cobalt, and Electron.},
articleno = 151,
}


@Article{DegenbaevLP2019,
  author = 	 "Degenbaev, Ulan and Lippautz, Michael and Payer, Hannes",
  title = 	 "Garbage collection as a joint venture",
  journal = 	 CACM,
  year = 	 2019,
  volume = 	 62,
  number = 	 6,
  pages = 	 "36-41",
  month = 	 jun,
}


@InProceedings{BerezunB2014,
  author = 	 "Berezun, Daniil and Boulytchev, Dmitri",
  title = 	 "Precise garbage collection for {C++} with a non-cooperative compiler",
  crossref =  "CEESECR2014",
  abstract =
   {We describe a garbage collector for C++ implemented as a user-level library, which
    does not require a cooperative compiler but makes use of a custom
    garbage-collection-friendly heap implementation. We claim our garbage collector to be
    precise, i.e. capable to precisely identify all pointers to all managed objects,
    tolerant to the conventional C++ manual memory management, and safe in the sense that
    it does not affect the semantics of the program as long as a simple conventions,
    encouraged by library interface, are followed. We also discuss a performance
    penalties imposed by the usage of our library on an end-user program.},
articleno = 15,
}


@Article{Michael2004,
  author = 	 "Michael, Maged M",
  title = 	 "Hazard Pointers: Safe Memory Reclamation for Lock-Free Objects",
  journal = 	 "TPDS",
  year = 	 2004,
  volume = 	 15,
  number = 	 6,
  pages = 	 "491-504",
  month = 	 jun,
  abstract =
   {Lock-free objects offer significant performance and reliability advantages over
    conventional lock-based objects. However, the lack of an efficient portable lock-free
    method for the reclamation of the memory occupied by dynamic nodes removed from such
    objects is a major obstacle to their wide use in practice. This paper presents hazard
    pointers, a memory management methodology that allows memory reclamation for
    arbitrary reuse. It is very efficient, as demonstrated by our experimental
    results. It is suitable for user-level applications--as well as system
    programs--without dependence on special kernel or scheduler support. It is
    wait-free. It requires only single-word reads and writes for memory access in its
    core operations. It allows reclaimed memory to be returned to the operating
    system. In addition, it offers a lock-free solution for the ABA problem using only
    practical single-word instructions. Our experimental results on a multiprocessor
    system show that the new methodology offers equal and, more often, significantly
    better performance than other memory management methods, in addition to its
    qualitative advantages regarding memory reclamation and independence of special
    hardware support. We also show that lock-free implementations of important object
    types, using hazard pointers, offer comparable performance to that of efficient
    lock-based implementations under no contention and no multiprogramming, and
    outperform them by significant margins under moderate multiprogramming and/or
    contention, in addition to guaranteeing continuous progress and availability, even in
    the presence of thread failures and arbitrary delays.},
}


@InProceedings{DavisSSS2013,
  author = 	 "Davis, Matthew and Schachte, Peter and Somogyi, Zoltan and S\o{}ndergaard, Harald",
  authorASCII =  "Davis, Matthew and Schachte, Peter and Somogyi, Zoltan and Sondergaard, Harald",
  authorUTF = 	 "Davis, Matthew and Schachte, Peter and Somogyi, Zoltan and Søndergaard, Harald",
  title = 	 "A low overhead method for recovering unused memory inside regions",
  crossref =  "MSPC2013",
  abstract =
   {Automating memory management improves both resource safety and programmer
    productivity. One approach, region-based memory management [9] (RBMM), applies
    compile-time reasoning to identify points in a program at which memory can be safely
    reclaimed. The main advantage of RBMM over traditional garbage collection (GC) is the
    avoidance of expensive runtime analysis, which makes reclaiming memory much
    faster. On the other hand, GC requires no static analysis, and, operating at runtime,
    can have significantly more accurate information about object lifetimes. In this
    paper we propose a hybrid system that seeks to combine the advantages of both methods
    while avoiding the overheads that previous hybrid systems incurred. Our system can
    also reclaim array segments whose elements are no longer reachable.},
articleno = 4,
}


@InProceedings{JungLCKPK2023,
  author = 	 "Jung, Jaehwang and Lee, Janggun and Choi, Jaemin and Kim, Jaewoo and Park, Sunho and Kang, Jeehoon",
  title = 	 "Modular verification of safe memory reclamation in concurrent separation logic",
  crossref =  "OOPSLA2023",
  abstract =
   {Formal verification is an effective method to address the challenge of designing
    correct and efficient concurrent data structures. But verification efforts often
    ignore memory reclamation, which involves nontrivial synchronization between
    concurrent accesses and reclamation. When incorrectly implemented, it may lead to
    critical safety errors such as use-after-free and the ABA problem. Semi-automatic
    safe memory reclamation schemes such as hazard pointers and RCU encapsulate the
    complexity of manual memory management in modular interfaces. However, this
    modularity has not been carried over to formal verification. We propose modular
    specifications of hazard pointers and RCU, and formally verify realistic
    implementations of them in concurrent separation logic. Specifically, we design
    abstract predicates for hazard pointers that capture the meaning of validating the
    protection of nodes, and those for RCU that support optimistic traversal to possibly
    retired nodes. We demonstrate that the specifications indeed facilitate modular
    verification in three criteria: compositional verification, general applicability,
    and easy integration. In doing so, we present the first formal verification of
    Harris’s list, the Harris-Michael list, the Chase-Lev deque, and RDCSS with
    reclamation. We report the Coq mechanization of all our results in the Iris
    separation logic framework.},
articleno = 251,
}


@InProceedings{GuyerMF2006,
  author = 	 "Guyer, Samuel Z. and McKinley, Kathryn S. and Frampton, Daniel",
  title = 	 "{Free-Me}: a static analysis for automatic individual object reclamation",
  crossref =  "PLDI2006",
  pages = 	 "364–375",
  abstract =
   {Garbage collection has proven benefits, including fewer memory related errors and
    reduced programmer effort. Garbage collection, however, trades space for time. It
    reclaims memory only when it is invoked: invoking it more frequently reclaims memory
    quickly, but incurs a significant cost; invoking it less frequently fills memory with
    dead objects. In contrast, explicit memory management provides prompt low cost
    reclamation, but at the expense of programmer effort.This work comes closer to the
    best of both worlds by adding novel compiler and runtime support for compiler
    inserted frees to a garbage-collected system. The compiler's free-me analysis
    identifies when objects become unreachable and inserts calls to free. It combines a
    lightweight pointer analysis with liveness information that detects when short-lived
    objects die. Our approach differs from stack and region allocation in two crucial
    ways. First, it frees objects incrementally exactly when they become unreachable,
    instead of based on program scope. Second, our system does not require
    allocation-site lifetime homogeneity, and thus frees objects on some paths and not on
    others. It also handles common patterns: it can free objects in loops and objects
    created by factory methods.We evaluate free() variations for free-list and
    bump-pointer allocators. Explicit freeing improves performance by promptly reclaiming
    objects and reducing collection load. Compared to marksweep alone, free-me cuts total
    time by 22\% on average, collector time by 50\% to 70\%, and allows programs to run
    in 17\% less memory. This combination retains the software engineering benefits of
    garbage collection while increasing space efficiency and improving performance, and
    thus is especially appealing for real-time and space constrained systems.},
}


@InProceedings{HallenbergET2002,
  author = 	 "Hallenberg, Niels and Elsman, Martin and Tofte, Mads",
  title = 	 "Combining region inference and garbage collection",
  crossref =  "PLDI2002",
  pages = 	 "141-152",
  abstract =
   {This paper describes a memory discipline that combines region-based memory
    management and copying garbage collection by extending Cheney's copying garbage
    collection algorithm to work with regions. The paper presents empirical evidence that
    region inference very significantly reduces the number of garbage collections; and
    evidence that the fastest execution is obtained by using regions alone, without
    garbage collection. The memory discipline is implemented for Standard ML in the ML
    Kit compiler and measurements show that for a variety of benchmark programs, code
    generated by the compiler is as efficient, both with respect to execution time and
    memory usage, as programs compiled with Standard ML of New Jersey, another
    state-of-the-art Standard ML compiler.},
}


@InProceedings{Elsman2003,
  author = 	 "Elsman, Martin",
  title = 	 "Garbage collection safety for region-based memory management",
  crossref =  "TLDI2003",
  pages = 	 "123–134",
  abstract =
   {In this paper, we prove the safety of integrating region-based memory management and
    Cheney-style copying garbage collection. The safety property relies on a refinement
    of the region typing rules that forbids dangling pointers during evaluation.To
    accommodate the triggering of garbage collection at any step in the evaluation
    process, we base our type-safety result for the region-based system on a small-step
    contextual semantics and show that whenever a well-typed expression reduces to
    another expression, possibly by deallocating a region, then no dangling pointer is
    introduced. Because there are no dangling pointers in the initial heap, no dangling
    pointers appear during evaluation.Although in principle, the refinement of the region
    typing rules leads to less flexibility and can cause worse memory behavior than when
    dangling pointers are permitted, experiments show that, for a range of benchmark
    programs, the refinement has little effect on overall memory behavior.},
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% End
%%%


% LocalWords: gc InProceedings JumpM booktitle NEEDpages addr TPFG DijkstraLMSS
% LocalWords: SPECjbb Elipse Scholten Steffens TechReport Detlefs Univ CMU GCs
% LocalWords:  struct Kolodner LCS TR jul Boehm Juergen PLDI Comm pp Smalltalk
% LocalWords:  BrouHaHa TelTL Tel Leeuwen STACS Augusteijn Proc PARLE LNCS jun
% LocalWords:  Eindhoven KoikeT Hanpei Koike Hidehiko Tanaka ASTEM NEEDaddress
% LocalWords:  nov nonsynchronized Halstead Multilisp toplas Kranz Mul AliH NY
% LocalWords:  techreport Khayri Haridi Seif feb RC PEs PE ext HudakK Rudalics
% LocalWords:  inproceedings Conf aug LiskovL Ladin Rivka Symp inlist SharmaS
% LocalWords:  Ravi Sharma Soffa oct Destructors Finalizers POPL finalizers NS
% LocalWords:  finalizer Nandakumar Sankaran ftp techreports dvi ps Chong kranz
% LocalWords:  Dampier dampier Liskov's Wiehl's Multimax SPARC Furman VG Guttag
% LocalWords:  Vandevoorde Hsieh EllisLA ShapiroPG noncomprehensive mtv wchsieh
% LocalWords:  mbr CRL rivka Krantz Anant Agarwal steele com Stamos Trans Syst
% LocalWords:  Comput SCG PARC Palo UCB CSD CSL Appel's WLM Moher crossref Malo
% LocalWords:  PHDTHESIS Ungar BookTitle SIGSOFT UngarJ Symbolics's wilson IWMM
% LocalWords:  Abdullahi Ringwood Hudak MillerE MultiScheme Jouannaud sep PMG
% LocalWords:  GOTEBORG Goteborg ManciniS Shrivastava Tyne Kai Appel Centre cdr
% LocalWords:  Lytton mastersthesis Venkatasubramanian Nalini DiwanMH Amer Tzi
% LocalWords:  Diwan NorthR Reppy Fenichel Yochelson Compactifying Schorr cker
% LocalWords:  Brownbridge Chiueh Thacker Int'l Langs ASPLOS Passau Mattern Jos
% LocalWords:  Friedemann Piquer Queinnec Beaudoing Queille INSPEC Bevan Kung
% LocalWords:  Comp Sci Ari JUne PhdThesis dec MastersThesis Nori TRs Stallman
% LocalWords:  Herlihy SRC Modula DeTreville Lins EUROMICRO JP TransPive Knowl
% LocalWords:  Bagherzadeh Keun BWW FY FP Zhibo Alvey Vectorized Bendiksen aka
% LocalWords:  Supercomput vectorized Cyber timestamp Schelvis Crammond Int Fi
% LocalWords:  Parlog Karia varisized RP DEA INRIA PrologII Pixley Distrib intl
% LocalWords:  COMPSAC sw intermode DBMS DeAL Rc assertDisjoint unsafeAssert
